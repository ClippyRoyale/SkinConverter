version,7,1,0 # The version of the Converter app that this script is made for.

# Metadata: doesn't affect how the script runs but will be displayed before running the script.
name,documentation
author,clippy
description,The documentation for the skin converter.

open,smb_skin*.png # Main image to open and copy from. Skip this line entirely if you want the user to enter their own path. If you want to convert multiple images at once, enter a * in the place where you want the converter to insert a number; see "start"/"stop" below for more on this.

save,smb_edit*.png # Filename to save to. (WARNING: Any existing file with this name will be overwritten!) Skip this line entirely if you want the user to enter their own path. If you want to convert multiple images at once, enter a * in the place where you want the converter to insert a number; see "start"/"stop" below for more on this.

# If you want to convert a collection of sequentially-numbered images, use these commands. For example, the commands below mean that image #0 will be the first image converted, and image #42 will be the last image.
start,0
stop,42

template,smb_skin2580.png # Template image to copy/paste from in place. No user input offered here because this image is supposed to stay the same.

alt,smb_skin1.png # Alternate image to copy from.

base,blank # Add this code to use a blank template-sized image as the base; otherwise, the "open" image will be the base.
base,256,256 # Start with a blank image with the given size (instead of using the old image's size)

flag,loop_limit,10000 # To prevent infinite loops (or gotos) from freezing the converter, a script will crash if any single line of code runs 10,000 times. If you need to run a loop more (or fewer) times than that, you can manually change the loop limit. (Alias: loop_limit)
flag,index_from,1 # By default, loops start counting from 0. Setting this flag to 1 makes them start from 1 instead.
flag,closed_range,1 # By default, loops use closed ranges. For example "for,$i,0,10" runs for 0≤x<10. Enabling this flag makes it work like 0≤x≤10 instead.

# Everything above this line is a header command.
# Each one can only appear once. If you use the same header command more than once,
# only the first instance will be used.
# Header commands cannot contain subcommands or references to variables.
# Header commands will be ignored if they are placed inside a block (e.g. an if statement or a while loop).

# The main conversion code is below.
# <> = required arguments
# [] = optional arguments (with default value used when omitted)



# LOG/EXIT COMMANDS
# By default, the converter will run through the whole conversion script, then save the new image and exit.

warning,Your warning here (will be displayed onscreen after conversion)

error,Stop conversion without saving and display this optional message on the screen

exit # End the conversion early, but save the target file as is and exit properly.

skip # End the conversion early without saving or displaying an error message. Intended for use in batch conversion where you want to flag only files that meet specific criteria.

noop # Does nothing.

# Comment: The hash (#) and everything after it will be ignored by the interpreter.
# You may also want to "comment out" lines that aren't working in your scripts.



# BASIC COPYING COMMANDS
# For all commands in this section:
# If you don’t give x or y, apply command to whole image: x=0, y=0, width and height are the same as the image's width and height.
# If you give x and y but not width or height: width=16, height=16
# If you give x, y, and width, but not height: height=width 

copy,0[oldX],0[oldY],0[newX],0[newY],16[width],16[height] # Copy from old image to specified position in new image.

copyalt,0[oldX],0[oldY],0[newX],0[newY],16[width],16[height] # Copy from alt image to specified position in new image. (Alias: copy_alt)

copyfrom,old<imageName>,0[oldX],0[oldY],0[newX],0[newY],16[width],16[height] # Copy from any image ("old", "alt", "template", or even "new") to specified position in new image. (Alias: copy_from)

default,0[x],0[y],16[width],16[height] # Copy from template image to same position in new image.

defaultfrom,template<imageName>,0[x],0[y],16[width],16[height] # Copy from any image ("old", "alt", "template", or even "new") to same position in new image. (Alias: default_from)

clear,0[x],0[y],16[width],16[height] # Clear area from new image. (Alias: delete -- deprecated in v6.0.0 and later)

duplicate,0<oldX>,0<oldY>,0<newX>,0<newY>,16[width],16[height] # Copy an area on the NEW image to another position on the same canvas.

move,0<oldX>,0<oldY>,0<newX>,0<newY>,16[width],16[height] # Cut an area on the NEW image, and paste it in another position on the same canvas.

swap,0<x1>,0<y1>,16<x2>,0<y2>,16[width],16[height] # Swap the pixels contained in two different areas on the new image. The areas you want to swap must have the same width and height.



# TRANSFORMATION COMMANDS

resize,256<newWidth>,256[newHeight] # Resize the new image's canvas. Does not perform any scaling. Anchor top left. If no height given, create a square canvas.

rotate,90<degreesClockwise: multiple of 90>,0<x>,0<y>,16[size] # Rotate the area in place on the new image. Unlike copy commands, only one size argument is used, as the rotated area must be square.

flip,x<direction: x or y>,0[x],0[y],16[width],16[height]
# Flip the area in place on the new image. Unlike rotation, width and height can be different here.
# If you don’t give x or y, apply command to whole image: x=0, y=0, width and height are the same as the image's width and height.
# If you give x and y but not width or height: width=16, height=16
# If you give x, y, and width, but not height: height=width 



# FILTER COMMANDS

# All filters are applied in place to the specified area on the new image.

# For all commands in this section:
# If you don’t give x or y, apply command to whole image: x=0, y=0, width and height are the same as the image's width and height.
# If you give x and y but not width or height: width=16, height=16
# If you give x, y, and width, but not height: height=width 

# Before v6.1, these commands didn't have the "filter." prefix.

filter.grayscale,0[x],0[y],16[width],16[height] # Converts the area to grayscale (AKA black-and-white). For the command that literally makes the area only black and white (1-bit), use "threshold".

filter.invert,0[x],0[y],16[width],16[height] # Inverts the area. For example, black becomes white, and red becomes cyan.

filter.rgb,0<redAdjust: -255 to +255>,0<greenAdjust>,0<blueAdjust>,0[x],0[y],16[width],16[height] # Adjusts the R/G/B color balance. You can use all three adjust arguments at the same time to adjust brightness. (Alias: colorfilter, color_filter)

filter.opacity,0<adjust: -255 to +255>,0[x],0[y],16[width],16[height] # Adjusts the opacity (alpha) levels. Negative = more transparent, positive = more opaque.

filter.hsl,0<hueAdjust: -180 to +180>,0<saturationAdjust: -100 to 100>,0<lightnessAdjust: -100 to 100>,0[x],0[y],16[width],16[height] # Adjusts hue, saturation, and lightness at the same time.

filter.hue,0<adjust: -180 to +180>,0[x],0[y],16[width],16[height] # Adjusts the hue.

filter.saturation,0<adjust: -100 to +100>,0[x],0[y],16[width],16[height] # Adjusts the saturation (in HSLA color space). Positive adjust means more colorful. Negative adjust means less colorful. -100 means grayscale.

filter.lightness,0<adjust: -100 to +100>,0[x],0[y],16[width],16[height] # Adjusts the lightness (in HSLA color space). Positive adjust means lighter. Negative adjust means darker. -100 means all black, +100 means all white.

filter.fill,0<red: 0 to 255>,0<green: 0 to 255>,0<blue: 0 to 255>,255[alpha: 0 to 255],0[x],0[y],16[width],16[height] # Fills the area with the selected color.

filter.contrast,0<adjust: -128 to 128>,0[x],0[y],16[width],16[height] # Adjusts the contrast. -128 will make all non-transparent pixels medium gray; +127 will make all RGB values either 0 or 255 (8 colors).

filter.colorize,180<hue: 0 to 359>,50<saturation: 0 to 100>,50<lightness: 0 to 100>,0[x],0[y],16[width],16[height] # Colorizes specified area in place. Converts area to B&W, treats L=127.5 as the specified HSL color, and interpolates the rest from there. Ex.: if the base color was coral [hsl(0,100,75)], it'll turn black->gray50->white to red->coral->white.

filter.sepia,0[x],0[y],16[width],16[height] # Simplified colorize syntax for creating sepia-toned images. Based on hex code #a08060 or HSL(30,25,50)

filter.threshold,128<minWhite: 0 to 256>,0[x],0[y],16[width],16[height]
# Converts the image to 1-bit black & white based on a numeric lightness threshold, determined by grayscale (luma) value. Any number LESS THAN minWhite is black, any number GREATER or EQUAL is white. Set minWhite to 0 to make everything white. Set minWhite to 256 to make everything black.

filter.selcolor,red<color>,0<hueAdjust: -180 to +180>,0<saturationAdjust: -100 to 100>,0<lightnessAdjust: -100 to 100>,0<x>,0<y>,16<width>,16<height> # Selective color: selects all pixels that have hues within a given sixth of the HSL color wheel (red, yellow, green, cyan, blue, magenta), and applies the HSL shift filter to each of those pixels.

filter.2color,0<hue>,100<saturation>,50<lightness>,0[x],0[y],16[width],16[height] # Simulates the effect of a two-color print job, where one of the colors is black. The hue/saturation/lightness arguments are for the second color. Unlike colorize, this is not recommended for use with black-and-white images, as the filter uses saturation data to determine how much color each pixel should have.



# ADVANCED COMMANDS
# These commands build on the basic commands but allow you to do complicated tasks with fewer commands.

tile,0<copyX>,0<copyY>,16<copyWidth>,16<copyHeight>,0<pasteStartX>,0<pasteStartY>,16<pasteCountHoriz>,16<pasteCountVert>,open[copySource: old, template, or alt] # Create a tile pattern on the new image using a part of the old image. This command can be very useful but it’s not for beginners.



# DRAWING COMMANDS

use,draw # Initializes extra code needed for drawing. Required if you want to use any commands with the "draw" prefix.

# DRAW: SHAPES

draw.rect,0<x>,0<y>,16<width>,16<height>,0[outline: 0 for fill, 1 for outline, 2 for both] # Draw a rectangle with the top left corner at the given x and y.

draw.ellipse,0<x>,0<y>,16<width>,16<height>,0[outline: 0 for fill, 1 for outline, 2 for both] # Draw an ellipse with the top left "corner" at the given x and y.

draw.line,0<x1>,0<y1>,16<x2>,16<y2> # Draw a line from (x1,y1) to (x2,y2). Note that this is different from the width/height system used for everything else. The example coordinates would have a width and height of 17 pixels.

# DRAW: OPTIONS

draw.fillcolor,(rgb,255,0,0)<color> # Set the fill color.

draw.linecolor,(rgb,255,0,0)<color> # Set the outline color.

draw.linewidth,1<width> # Set the outline stroke width.

draw.alphablend,1<toggle> # Toggles alpha blending on (1) or off (0). If on, drawing partially transparent shapes will merge their colors with the existing pixels underneath. If off, the pixels underneath will by fully overwritten by the shapes. If this command is not called, alpha blending will be turned ON by default.



# CONTROL FLOW COMMANDS

if,(empty,0,0,16,16)
    # Run the commands here if the above condition is true
elseif,(empty,128,128,32,32)
    # Run the commands here if the first condition is false but the second condition is true
else
    # Otherwise, run the commands here
end 
# "end" is the preferred way to end blocks in 5.1+ but "endif" is supported for backwards compatibility

if1,(...) # Like if, but rather than being the start of a block, you just execute the next line if the conditional is true, then continue with the program.
    # This line is the only line inside the if "block". Maybe you could put a goto here?
# This line is just part of the normal program flow. No "end" needed.

label,hello # Mark a point in the code that you can jump to using "goto".

goto,hello # Jump to a label defined elsewhere in the code.
goto,10 # Jump to the start of line number 10. The first line of your program is 1.

gosub,hello<label> # Go to the label, and put the current line number onto the subroutine stack so you can come back to it later.
goback # Return from the subroutine to the last line number on the subroutine stack. (alias: retsub)

while,(...) # Keep repeating as long as the condition in argument 1 is true. TODO: Argument 2 will be "min_repeat" for minimum number of times loop must repeat, like a do-while loop

for,$i<loopVar>,0[start],10<stop>,1[step] # Create a loop based around incrementing a value by some amount. (BASIC-style for loop)

break,1<numLoops> # Break out of the current loop. If numLoops >= 1, break out of that many levels of loops (assuming loop is nested).

next # "continue" in C/Java/Python, but "next" is a better name because we're skipping to the next iteration of the loop.



# DATA COMMANDS

set,$hello<name>,"Hello world"<value> # Set variable "hello" to the string "Hello world". Subcommands in second argument will be evaluated before setting the variable. Any value in double quotes will be treated as a string no matter what. If it's not in quotes and it can be parsed as an integer, the value will be an integer. Anything else will be treated as a string for legacy reasons, but watch out for special characters!

change,$x<varName>,+<subcmdName>,10[arg2],... # Change the value of varName by applying the given subcommand to it. The variable will be the first argument to the command, and any argument after `subcmdName` will be passed as the subcommand's second, third, (etc.) arguments. Example A: `change,$x,+,10,$y` will add (10 plus the value of $y) to $x; this is equivalent to `set,$x,(+,$x,10,$y)`. Example B: `change,$x,*,2` will multiply $x's value by 2; this is equivalent to `set,$x,(*,$x,2)`. Basically, it's nothing you can't already do with set; it just makes code more readable.

const,$TAU,6.283 # Set a constant value so you can refer back to it by a recognizable name later. Works the same as "set" but you can't go back and change the value the name refers to.



# SUBCOMMANDS
# These are useful e.g. as conditions in if statements.

(empty,old[image],0<x>,0<y>,16[width],16[height]) # True if the area on the given image is completely empty (every pixel is transparent), False otherwise.

(len,"thing"<data>) # Length of any variable or literal. Most useful for strings and lists. Calls the python function of the same name.



# EQUALITY SUBCOMMANDS
# These work exactly the way you'd expect.
# Can be called using Unicode symbols (≥), ASCII approximations (>=), or letters (ge, gte).

(=,x1,x2,...)	# or ==, eq
(!=,x1,x2,...)	# or ≠, <>, ne
(<,x1,x2,...)	# or lt
(>,x1,x2,...)	# or gt
(<=,x1,x2,...)	# or ≤, le
(>=,x1,x2,...)	# or ≥, ge



# LOGICAL SUBCOMMANDS
# These also work exactly the way you'd expect.
# Can be called with Python keywords (and) or C operators (&&).

(and,<subcmd1>,<subcmd2>,[subcmd3],...)
(or,<subcmd1>,<subcmd2>,[subcmd3],...)
(not,<subcmd1>)



# MATH SUBCOMMANDS
# These mostly work exactly the way you'd expect, except unlike in Python they can't be used on strings.

(+,x1,x2,...)	# or add
(-,x1,x2,...)	# or sub, − [minus sign], or – [en dash]
(-,x)           # unary minus, negates x
(*,x1,x2,...)	# or mul, ×
(/,x1,x2,...)	# or truediv, ÷
(div,x1,x2,...)	# integer division (or floordiv). May use // as future alias but I'll wait for now
(mod,x1,x2,...) # modulo. May use % as future alias but I'll wait for now
(^,x1,x2,...) # x1 to the x2-th power, and so on. Technically you *can* add x3, x4, etc but it'll make the program crash VERY quickly. (Alias: pow)

(floor,x1) # Floor: returns the nearest int <= x1
(ceil,x1) # Ceiling: returns the nearest int >= x1 (alias: ceiling)
(abs,x1) # Absolute value: makes x1 positive if it isn't already

(min,x1,x2...) # Returns the minimum value out of the arguments passed in.
(max,x1,x2...) # Returns the maximum value out of the arguments passed in.



# SEQUENCE SUBCOMMANDS
# For working with the data sequence types, strings and lists.

(get,$x<var>,0<index>) # Gets the item at index 0 of the given list/string. The first item of the list/string has index 0, unless you change the index_from flag. In addition, index -1 is the last item, -2 is the second-to-last item, etc. Name taken from Python's <dict>.get() method, because "sub" (subscript) was already taken by subtraction.

(str+,"Hello"<s1>,"World"<s2>,...) # (or str_add) Concatenate two or more values. The inputs don't have to be strings, but the output will always be a string. The output in the preceding example is "HelloWorld" (with no space in between because neither string had a space in it).
(str*,"Hello"<s>,3<n>) # (or str_mul) Repeat s, n times. s doesn't have to be a string, but the output will always be a string. n must be an integer.

(list,x1,x2,x3,...) # Creates an editable, variable-length list with the given items.



# TYPE SUBCOMMANDS
# For converting between data types.

(int,1.5) # Convert a value to integer format, if possible.
(int,"0f"<value>,16[base]) # Only for string values: you can specify the base the string is in (from 2-36), and it'll convert it correctly.
(float,1)
(str,1) # alias: string
(bool,1) # alias: boolean

(type,$x<data>) # Returns the data type of the given variable (or literal), as a string. Possible types: "int", "float", "str", "bool", "color"



# COLOR TYPE SUBCOMMANDS
# These commands return the Color data type.

(color,"#ff0000"<hex>) # Define a color based on a *string* consisting of a "#" followed by 6 or 8 hexademical numbers. Hex codes can be in the format #RRGGBB or #AARRGGBB (e.g. "#80ffff00" will be a 50% transparent yellow).
(color,"red"<name>) # Define a color based on this list of 24 color names:
    red: #ff0000
    maroon: #800000
    orange: #ff8000
    brown: #804000
    tan: #c08040
    peach: #ffd0a0
    amber: #ffc000
    yellow: #ffff00
    olive: #808000
    lime: #00ff00
    green: #008000
    cyan: #00ffff
    teal: #008080
    azure: #0080ff
    blue: #0000ff
    navy: #000080
    violet: #8000ff
    purple: #800080
    magenta: #ff00ff
    pink: #ff80ff
    black: #000000
    gray: #808080
    silver: #c0c0c0
    white: #ffffff

(rgba,0<red: 0 to 255>,0<green: 0 to 255>,0<blue: 0 to 255>,255[alpha: 0 to 255]) # Alias: rgb

(hsla,0<hue: 0 to 359>,100<saturation: 0 to 100>,50<lightness: 0 to 100>,255[alpha: 0 to 255]) # Define a color based on the hue/saturation/lightness (or luminosity) model, plus optional alpha. (Alias: hsl)



# COLOR INFO SUBCOMMANDS
# These return RGBA, HSLA, etc. color values of a pixel, or (if width and height are given) the average value across an area (as an integer). You can specify the name of an image you want to get the data point from, or go right to coordinates if you want to get data from the old image.

(red,old[image],0<x>,0<y>,1[width],1[height]) # Return the red value (from 0 to 255) of a single pixel. If width and height are given, take the average value over the given rectangle.
(green,old[image],0<x>,0<y>,1[width],1[height])
(blue,old[image],0<x>,0<y>,1[width],1[height])

(alpha,old[image],0<x>,0<y>,1[width],1[height]) # This is for GETTING the alpha value (from 0 to 255). For applying a transparency filter, use "opacity".

(hue,old[image],0<x>,0<y>,1[width],1[height]) 		# from 0 to 359
(saturation,old[image],0<x>,0<y>,1[width],1[height])	# In the HSL sense; from 0 to 100
(lightness,old[image],0<x>,0<y>,1[width],1[height])	# Not to be confused with value AKA brightness; from 0 to 100 (alias: luminosity)

# The same commands can be used on color values and variables:
(red,(rgb,255,128,0)<color>) # Return the red attribute of a color.
(green,(rgb,255,128,0)<color>)
(blue,(rgb,255,128,0)<color>)
(alpha,(rgb,255,128,0)<color>)
(hue,(rgb,255,128,0)<color>)
(saturation,(rgb,255,128,0)<color>)
(lightness,(rgb,255,128,0)<color>) # (alias: luminosity)



# IMAGE INFO SUBCOMMANDS
# These return info about a named image.

(width,open<imageName>) # Returns the width of the image with the specified name.
(height,open<imageName>) # Returns the height of the image with the specified name.



# COMING SOON:
# Anything here is subject to change, and syntax should not be treated as final.

# I'm unlikely to add switch statements, because they just open up a bunch of cans of worms when I start thinking about implementation.

from,old<image>,<cmd> # Set the source image for the following command. Can be combined with "to" (see below).

to,new<image>,<cmd> # Set the target image for the following command. Target image must be writeable.

scale,256<newWidth>,256<newHeight> # Scale the image to the new width and height, using nearest-neighbor scaling (add other algorithms? add percentages? scale specific areas as part of copying?)

copyscale,0<oldX>,0<oldY>,32<oldWidth>,32<oldHeight>,0<newX>,0<newY>,16<newWidth>,16<newHeight>,1[algo] # Copy from the old image to the new image, while 
# ^ TODO: Don't include an "image" argument because "from" will be used to set the source image from now on.

# SUBCOMMANDS

# Color subcommands:
(luma,0<x>,0<y>,1[width],1[height]) # The value that would be used if the image were converted to grayscale

# Math subcommands:
(min,(list,x1,x2,...)) # min/max for LISTS -- already added for loose arguments
(max,(list,x1,x2,...))
(round,1.2<x>,$_false[decPlaces]) # Round using standard mathematical rules. If an int is given for decPlaces, return a float rounded to that many decimal places. (Negative integers allow you to round to higher place values; e.g. -1 = round to tens place). If decPlaces is not given or is set to a non-integer value, return an int.
# No trigonometry, calculus, bitwise operators, logarithms, factorial, etc. -- all of those seem like overkill for what's supposed to be an image-editing program

# LOOPS
foreach,$i<loopVar>,$l<list> # Create a loop based around iterating through a list. (Python-style for loop)
(range,0[start],10<stop>,1[step]) # Generates a list of integers from start to stop (not including stop), stepping by 1 each time. For example, the sample code generates the list [0,1,2,3,4,5,6,7,8,9]
# Ruby's "redo" and "retry" are probably too rare to be worth implementing. They can easily be replicated with gotos

# VARIABLES
load,alt2<name>,smb_skin2580.png<path> # Load the image at the given path and store it associated with the given string identifier. This is a header command, so it will always be called once at the start of the program and it can't be used with variables. The image cannot be retrieved like a variable, but it does block its name from being used for variables. TODO: Maybe call this "setpath"? Or "source"? Reserve "read" for a possible future non-header version
# TODO: +=, -=, *=, /=, ++, -- for common variable changes? Or does this not make sense if the standard keyword is "set"?

# STRINGS
# TODO: Get rid of prefix? Seems like it adds complexity that isn't in Python in terms of distinguishing between string and list operations.
(str.upper,$s) # Convert string to all caps
(str.lower,$s) # Convert string to all lowercase

# LISTS
$l1[0] # Returns the item at index 0 of the given list. The first item of the list has index 0, unless you change the index_from flag. Index -1 is the last item, -2 is the second-to-last item, etc. There are two ways to do this, because you can only use the former if you're getting an item from a list returned by a subcommand, and you can only set list items with the latter.
(list.slice,$l<listVar>,0[start],2<stop>,1[step]) # Returns a sublist of the given list. Entering "_" for stop means slice the entire rest of the list.
list.append,$l<listVar>,"thing"<item>,0[index] # Add an item to an existing list (in place). If an index argument is given, insert the item BEFORE the given index. Otherwise, add the item to the end
list.remove,$l<listVar>,0<index> # Remove the item at the given index from the list; shift the items after it to the left.
list.sort,$l<listVar> # Sorts the list in place, in ascending numerical order according to Python's built-in Timsort algorithm.
(list.sorted,$l<listVar>) # Returns a sorted version of list l, but does not change the original list.
list.reverse,$l<listVar> # Reverses the list in place, so that the first item and the last item are swapped, the second and second-to-last are swapped, and so on.
(list.reversed,$l<listVar>) # Returns a reversed version of list l, but does not change the original list.
# TODO: list concatenation and repetition -- do I need an operator that's used for both lists and strings?
# TODO: find -- returns index of first matching item

# COLOR DEFINITIONS
(gray,50<luma>) # Define a grayscale color based on [HSL lightness or luma?]
(nes,"0f"<hex>) # Defines a color from the NES palette. More specifically, the colors are from Nestopia's Canonical palette (AKA YUV-V1). I know some people have strong feelings about what the "best" NES palette is, but Canonical has the best mathematical basis for its colors.

# TEXT DRAWING
draw.text,"Hello world"<textContent>,0<x>,0<y>,80[width],24[height],-1<outline: -1 for no box, 0 for fill, 1 for outline, 2 for both> # Draw a text box with the given text. x and y are the position of the top left corner. Width and height are in pixels -- NOT characters/lines. Any text past the maximum width will be wrapped to the next line. Any text past the maximum height will be cut off, with ellipsis in the bottom right corner. If outline is set to 0, 1, or 2: a rectangle with the given width and height will be drawn under the text. 
(draw.trytext,"Hello world"<textContent>,0<x>,0<y>,80[width],24[height],-1<outline: -1 for no box, 0 for fill, 1 for outline, 2 for both>) # Works the same as draw.text, except that instead of actually drawing the text box, return a list with the width and height the box WOULD have.

# TEXT DRAWING OPTIONS
draw.textcolor,(rgb,0,0,0)<color> # Set text color. This is different from outline and fill color to make it easier to draw text boxes.
draw.textsize,1<scaleX>,1[scaleY] # Change the size of text from the usual 1:1 ratio. Argument(s) must be positive integers. If 1 argument is given, y-scale and x-scale are assumed to be the same.
draw.font,smb<fontName> # Set the font used to draw text. Name X should have a corresponding "X.png" in the fonts folder in a 16×16 extended ASCII table. Default is "arcade".
draw.letterspacing,0<amount> # Set the amount of extra space between each character (AKA tracking/kerning) when drawing text. Can be positive or negative; default is 0 (no spacing).
draw.linespacing,0<amount> # Set the amount of extra space between each line (AKA leading) when drawing text. Can be positive or negative; default is 0 (set solid).

# LAYERS
layer.new,0<depth>,layer0[name] # Create a new layer. Default depth is right in front of currently selected layer. Default name based on the given depth. For depth, higher numbers are at the front. TODO: Better system for layer depth
layer.select,0<depth OR name> # Set which layer you're currently working on.

# (Lower-priority layer commands)
layer.show,0[target: depth OR name] # Default to current layer
layer.hide,0[target: depth OR name]
layer.delete,0[target: depth OR name]
layer.merge,0[fromlayer: depth OR name],0[tolayer: depth OR name] # Default to merging current layer down to the layer behind it
layer.mergevisible # Merge all visible layers

# FUNCTIONS
func,(sqrt,@x:int,@y=2),int # Local variables use @ at start instead of $
return # Return from function. Not to be confused with retsub (for subroutines)
